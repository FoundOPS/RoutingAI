using RoutingAI.DataContracts;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace RoutingAI.Algorithms.Interfaces
{
    /// <summary>
    /// Interface representing a filter that filters elements of
    /// a collection based on a constraint
    /// </summary>
    public abstract class ConstraintFilterBase :
        IEnumerable<Task>
    {
        /// <summary>
        /// Resource group the filter is filtering for
        /// </summary>
        protected Resource resource;
        /// <summary>
        /// Confidence-adjusted time window of all already optimized tasks
        /// </summary>
        protected Window optimizedWindow;
        /// <summary>
        /// Collection of unvisited tasks to filter
        /// </summary>
        protected ICollection<Task> unvisited;
        /// <summary>
        /// Path produced by the optimizer, up to current point
        /// Last entry will be used as the current point
        /// </summary>
        protected IList<Task> path;

        // Linq Query generated by this class
            // NOTE: Values are fetched at enumeration so if collection is changed the results will change as well
        private IEnumerable<Task> queryCache = null;    // Linq Query

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="resource">Resource group the filter is filtering for</param>
        /// <param name="optimized">Confidence-adjusted time window of all already optimized tasks</param>
        /// <param name="unvisited">Collection of unvisited tasks to filter</param>
        /// <param name="path">Path generated by optimizer up to this point</param>
        protected ConstraintFilterBase(Resource resource, Window optimized, ICollection<Task> unvisited, IList<Task> path)
        {
            this.resource = resource;
            this.unvisited = unvisited;
            this.path = path;
            optimizedWindow = optimized;
        }

        /// <summary>
        /// When implemented, determines whether two tasks can be linked based on various
        /// constraints.
        /// </summary>
        /// <param name="current">Last already-optimized task</param>
        /// <param name="next">Next possible task</param>
        /// <returns>True if tasks can be linked; false otherwise</returns>
        public abstract Boolean CanLink(Task current, Task next);

        #region IEnumerable Members

        public IEnumerator<Task> GetEnumerator()
        {
            if (queryCache == null)
            {
                Task current = path[path.Count - 1];
                queryCache = from t in unvisited where CanLink(current, t) select t;
            }
            return queryCache.GetEnumerator();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            if (queryCache == null)
            {
                Task current = path[path.Count - 1];
                queryCache = from t in unvisited where CanLink(current, t) select t;
            }
            return queryCache.GetEnumerator();
        }

        #endregion

    }
}
